#!/usr/bin/env gjs

/*! (c) Andrea Giammarchi - ISC */

const { gi } = imports;
const { GLib, Gio } = gi;
const { File } = Gio;

const DIR = GLib.get_current_dir();
const PROGRAM = resolve(DIR, imports.system.programInvocationName);
const cache = Object.create(null);

Object.defineProperty(window, 'global', {value: window});

window.__dirname = getProgramDir(PROGRAM).get_path();
window.__filename = PROGRAM.get_path();

window.require = file => {
  if (/^[A-Z]/.test(file))
    return file.split('.').reduce((nmsp, k) => nmsp[k], gi);
  if (!/\.m?js$/.test(file))
    file += '.js';
  const { __dirname, __filename } = window;
  const fd = resolve(__dirname, file);
  window.__filename = fd.get_path();
  if (window.__filename in cache)
    return cache[window.__filename];
  window.__dirname = fd.get_parent().get_path();
  const exports = {};
  const module = { exports };
  window.exports = exports;
  window.module = module;
  imports.searchPath.unshift(window.__dirname);
  try {
    imports[fd.get_basename().replace(/\.m?js$/, '')];
    cache[window.__filename] = module.exports;
  }
  catch (error) {
    print(error);
  }
  imports.searchPath.shift();
  window.__filename = __filename;
  window.__dirname = __dirname;
  return module.exports;
};

ARGV.forEach(arg => {
  const fd = resolve(DIR, arg);
  if (fd.query_exists(null))
    window.require(fd.get_path());
});

function resolve(dir, file) {
  return File.new_for_path(dir).resolve_relative_path(file);
}

function getProgramDir(programFile) {
  const info = programFile.query_info('standard::', Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null);
  if (info.get_is_symlink()) {
    const symlinkFile = programFile.get_parent().resolve_relative_path(info.get_symlink_target());
    return symlinkFile.get_parent();
  } else {
    return programFile.get_parent();
  }
}
